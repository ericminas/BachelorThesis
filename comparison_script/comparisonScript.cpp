/* Documentation
 * This tests the provided subjects with files generated by Format Fuzzer.
 * Required Arguments:
 * test_runs     {int}       - The number of files that should be generated for each subject.
 * pathToFuzzers {string}    - The path to the parent directory of the fuzzers.
 *
 * Optional Args
 * --clean-start {void}       - Whether the files in the findings folder should be deleted before the program starts
 *
 * Notes:
 * - numberOfGeneratedFiles  - Range: [1 , 10^6].
 * - pathToFuzzers           - The fuzzers should be called: "ogg-fuzzer" and "flac-fuzzer".
 */

#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <iostream>
#include <stdexcept>
#include <cstdio>
#include <memory>
#include <array>
#include <regex>

using namespace std;

//////////////////// constants & shared vars ////////////////////
string script_dir = "/subject_scripts/";
string findings_dir = "/findings";

string subjects[5] = {"dr_libs", "miniaudio", "mp3splt", "xiph_flac", "libogg"};
string fileType[5] = {"flac", "flac", "ogg", "flac", "ogg"};

int TEST_RUNS = 0;
string pathToFuzzers = "";

string ogg_command = "";
string flac_command = "";

string last_msg = "";
/////////////////////////////////////////////////////////////////

string exec(const char *cmd)
{
    char buffer[128];
    string result = "";
    FILE *pipe = popen(cmd, "r");
    if (!pipe)
        throw std::runtime_error("popen() failed!");
    try
    {
        while (fgets(buffer, sizeof buffer, pipe) != NULL)
        {
            result += buffer;
        }
    }
    catch (...)
    {
        pclose(pipe);
        throw;
    }
    pclose(pipe);
    return result;
}

void printMessageBar(string msg, int offset, bool useLML)
{
    string halfBar = "====================";

    if (msg.length() > 0)
    {

        string offsetEqls = "";
        offsetEqls.append(offset, '=');

        cout << halfBar << offsetEqls << " " << msg << " " << halfBar << offsetEqls << endl;
        last_msg = msg;
    }
    else
    {
        string offsetEqls = "";
        if (useLML)
        {
            offsetEqls.append(last_msg.length() + 2, '=');
        }
        offsetEqls.append(offset, '=');

        cout << halfBar << halfBar << offsetEqls << endl;
    }
}

int testSubject(string subjectName, string fileType)
{
    printMessageBar(subjectName, 30, false);
    string test_command = "." + script_dir + subjectName + "_TS " + "./generated/out." + fileType;
    string move_command = "mv ./generated/out." + fileType + " ./findings/" + subjectName + "/";
    string output = "";
    int crashes = 0;

    for (int i = 0; i < TEST_RUNS; i++)
    {
        //  generate a file
        if (fileType == "ogg")
        {
            exec(ogg_command.c_str());
        }
        else if (fileType == "flac")
        {
            exec(flac_command.c_str());
        }

        // call the subject with the file
        output = exec(test_command.c_str());

        // check the console output / whether a error was thrown
        // TODO this moves everything into the crash folder
        if (output.find("aborted") != string::npos || output.find("core dump") != string::npos)
        {
            // move most recent file to findigs
            string cmd = move_command + "crash_" + to_string(crashes) + "." + fileType;
            exec(cmd.c_str());

            // notify
            cout << "found crash #" << crashes << " moved file to findings/" << subjectName << endl;

            crashes++;
        }
    }

    return 0;
}

void validateDirs()
{
    cout << "-------------------- checking dirs --------------------" << endl;
    string required_dirs[7] = {"generated", "findings", "findings/dr_libs", "findings/libogg", "findings/miniaudio", "findings/mp3splt", "findings/xiph_flac"};
    string cmd = "";
    string out = "";
    bool shouldStop = false;

    for (int i = 0; i < (sizeof(required_dirs) / sizeof(required_dirs[0])); i++)
    {
        // check existance
        cmd = "[ -d \"./" + required_dirs[i] + "\" ] && echo \"exists\"";
        out = exec(cmd.c_str());

        if (out.find("exists") == string::npos)
        {
            cout << required_dirs[i] << " does not exist" << endl;
            shouldStop = true;
        }
        else
        {
            cout << "found: " << required_dirs[i] << endl;
        }
    }

    if (shouldStop)
    {
        abort();
    }
}

void cleanUpFiles()
{
    cout << "TODO implement file clean up" << endl;
}

int main(int argc, char **argv)
{
    // get args
    if (argc < 3)
    {
        cout << "not enough arguments provided. Check the documentation at the top of the file." << endl;
        abort();
    }

    TEST_RUNS = stoi(argv[1]);
    pathToFuzzers = argv[2];

    if (TEST_RUNS < 0 || TEST_RUNS >= 1000000 || pathToFuzzers.length() == 0 || pathToFuzzers.back() != '/')
    {
        cout << "at least one argument is missing or invalid" << endl;
        abort();
    }

    // create the file generation commands
    ogg_command = pathToFuzzers + "ogg-fuzzer fuzz ./generated/out.ogg";
    flac_command = pathToFuzzers + "flac-fuzzer fuzz ./generated/out.flac";

    // check for cleanStart flag
    // TODO / FIXME the string should be correct but is not
  /*  cout << argc<<" "<<argv[3] <<" found "<<(argc == 4) <<" && "<< (argv[3] == "--clean-start" )<< endl;
    if (argc >= 4 && argv[3] == "--clean-start")
    {
        cleanUpFiles();
    }*/

    // welcome message
    printMessageBar("starting comparison script", 20, false);
    // print args
    cout << "test runs: " << TEST_RUNS << endl;
    cout << "path to fuzzers: " << pathToFuzzers << endl;
    cout << "ogg  generation command: " << ogg_command << endl;
    cout << "flac generation command: " << flac_command << endl;
    // check required dirs
    validateDirs();
    printMessageBar("", 40, true);

    // test subjects

    for (int i = 0; i < (sizeof(subjects) / sizeof(subjects[0])); i++)
    {
        testSubject(subjects[i], fileType[i]);
    }
    // evaluate

    // clean up
    // TODO remove the generated files
    return 0;
}
