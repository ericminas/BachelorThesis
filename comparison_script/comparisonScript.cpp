/* Documentation
 * This tests the provided subjects with files generated by Format Fuzzer.
 * Required Arguments:
 * test_runs     {int}       - The number of files that should be generated for
 * each subject. pathToFuzzers {string}    - The path to the parent directory of
 * the fuzzers.
 *
 * Optional Args
 * -c            {void}      - Whether the files in the findings folder should
 * be deleted before the program starts
 *
 * Notes:
 * - numberOfGeneratedFiles  - Range: [1 , 10^6].
 * - pathToFuzzers           - The fuzzers should be called: "ogg-fuzzer" and
 * "flac-fuzzer".
 */

#include <stdio.h>
#include <stdlib.h>

#include <array>
#include <cstdio>
#include <iostream>
#include <memory>
#include <regex>
#include <stdexcept>
#include <string>

using namespace std;

//////////////////// constants & shared vars ////////////////////
string script_dir = "/subject_scripts/";
string findings_dir = "/findings";

string subjects[5] = {"dr_libs", "miniaudio", "mp3splt", "xiph_flac", "libogg"};
string fileType[5] = {"flac", "flac", "ogg", "flac", "ogg"};

int TEST_RUNS = 0;
int PRINT_LENGTH = 120;
string pathToFuzzers = "";

string ogg_command = "";
string flac_command = "";

string last_msg = "";
/////////////////////////////////////////////////////////////////

string exec(const char *cmd) {
    char buffer[128];
    string result = "";
    FILE *pipe = popen(cmd, "r");
    if (!pipe) throw std::runtime_error("popen() failed!");
    try {
        while (fgets(buffer, sizeof buffer, pipe) != NULL) {
            result += buffer;
        }
    } catch (...) {
        pclose(pipe);
        throw;
    }
    pclose(pipe);
    return result;
}

void printMessageBar(string msg) {
    // handle padding
    int padding = PRINT_LENGTH - (msg.length() + 2);
    padding = padding > 0 ? padding : 0;

    if (padding % 2 != 0) {
        padding--;
        msg += " ";
    }

    // top / bottom bar
    string bar = "#";
    bar.append(118, '=');
    bar += "#";

    // format message
    string pad = "";
    pad.append(padding > 0 ? (padding / 2) : 0, ' ');
    string content = "#" + pad + msg + pad + "#";

    // print
    cout << bar << endl;
    cout << content << endl;
    cout << bar << endl;
}

void printMessage(string msg, char paddingChar){
    // handle padding
    int length = PRINT_LENGTH - msg.length();
    int padding = length > 0 ? (length - 2) / 2 : 0;

    string pad = "";
    pad.append(padding, paddingChar);
    msg = " " + msg + " ";

    cout << pad << msg << pad << (length % 2 == 0 ? ' ' : paddingChar) << endl;
}

int testSubject(string subjectName, string fileType) {
    printMessageBar("Testing: " + subjectName);
    string test_command =
        "." + script_dir + subjectName + "_TS " + "./generated/out." + fileType;
    string move_command =
        "mv ./generated/out." + fileType + " ./findings/" + subjectName + "/";
    string output = "";
    int crashes = 0;

    for (int i = 0; i < TEST_RUNS; i++) {
        // print current test
        if(TEST_RUNS > 1){
            printMessage(subjectName+" test #"+to_string(i), '.');
        }

        //  generate a file
        if (fileType == "ogg") {
            exec(ogg_command.c_str());
        } else if (fileType == "flac") {
            exec(flac_command.c_str());
        }

        // call the subject with the file
        output = exec(test_command.c_str());

        // check the console output / whether a error was thrown
        if (output.find("aborted") != string::npos ||
            output.find("core dump") != string::npos) {
            // move most recent file to findigs
            string cmd =
                move_command + "crash_" + to_string(crashes) + "." + fileType;
            exec(cmd.c_str());

            // notify
            printMessage("found crash #" + to_string(crashes) + ". Moved the file to findigs/"+subjectName,'/');

            crashes++;
        }
    }

    return 0;
}

void evaluateSubject(string subjectName, string fileType, int crashes) {
    float percentage = ((float) crashes / (float) TEST_RUNS);
    percentage *= percentage < 1 ? 100 : 1;
    
    subjectName = subjectName.length() <= 6 ? subjectName + " " : subjectName;
    fileType = fileType == "ogg" ? "ogg " : fileType;

    printf("%s:\t\t\t out of %d generated %s files, %d crashes were found.\t(%3.0f%% )\n", subjectName.c_str(), TEST_RUNS, fileType.c_str(), crashes, percentage);
}

void validateDirs() {
    printMessage("checking dirs", '-');
    string required_dirs[7] = {"generated",          "findings",
                               "findings/dr_libs",   "findings/libogg",
                               "findings/miniaudio", "findings/mp3splt",
                               "findings/xiph_flac"};
    string cmd = "";
    string out = "";
    bool shouldStop = false;

    for (int i = 0; i < (sizeof(required_dirs) / sizeof(required_dirs[0]));
         i++) {
        // check existance
        cmd = "[ -d \"./" + required_dirs[i] + "\" ] && echo \"exists\"";
        out = exec(cmd.c_str());

        if (out.find("exists") == string::npos) {
            cout << required_dirs[i] << " does not exist" << endl;
            shouldStop = true;
        } else {
            cout << "found: " << required_dirs[i] << endl;
        }
    }

    if (shouldStop) {
        abort();
    }
}

void cleanUpFiles() {
    printMessageBar("clean up files in findings");

    // lopp through the dirs
    string path = "./findings/";
    string command = "";
    for (int i = 0; i < (sizeof(subjects) / sizeof(subjects[0])); i++) {
        cout << "remove files from: " << path << subjects[i] << endl;
        command = "rm " + path + subjects[i] + "/*";

        exec(command.c_str());
    }
}

int main(int argc, char **argv) {
    // get args
    if (argc < 3) {
        cout << "not enough arguments provided. Check the documentation at the "
                "top of the file."
             << endl;
        abort();
    }

    TEST_RUNS = stoi(argv[1]);
    pathToFuzzers = argv[2];

    if (TEST_RUNS < 0 || TEST_RUNS >= 1000000 || pathToFuzzers.length() == 0 ||
        pathToFuzzers.back() != '/') {
        cout << "at least one argument is missing or invalid" << endl;
        abort();
    }

    // create the file generation commands
    ogg_command = pathToFuzzers + "ogg-fuzzer fuzz ./generated/out.ogg";
    flac_command = pathToFuzzers + "flac-fuzzer fuzz ./generated/out.flac";

    if (argc >= 4) {
        string flag = argv[3];
        if (flag == "-c") {
            cleanUpFiles();
        }
    }

    // welcome message
    printMessageBar("Arguments and Metadata for the script");
    // print args
    cout << "test runs: " << TEST_RUNS << endl;
    cout << "path to fuzzers: " << pathToFuzzers << endl;
    cout << "ogg  generation command: " << ogg_command << endl;
    cout << "flac generation command: " << flac_command << endl;
    // check required dirs
    validateDirs();

    // test subjects
    int crashes[5];
    for  (int i = 0; i < (sizeof(subjects) / sizeof(subjects[0])); i++) {
       crashes[i] = testSubject(subjects[i], fileType[i]);
    } 

    // evaluate
    printMessageBar("Evaluation Results");
    for  (int i = 0; i < (sizeof(subjects) / sizeof(subjects[0])); i++) {
        evaluateSubject(subjects[i], fileType[i], crashes[i]);
    }

    return 0;
}
